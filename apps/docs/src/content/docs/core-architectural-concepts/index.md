---
title: Глоссарий
description: Глоссарий
---

### Информация
Информация – совокупность знаний об объекте.

### Данные
Данные – закодированная информация.

### Состояние
Состояние – хранимые в системе данные.

Обычно состояние представляет собой данные с длительным сроком жизни.

Например, если данные используются только для промежуточных вычислений (как переменная i в цикле), это не считается состоянием.

Состояние — это "долгоживущая" переменная, такая как state, которая изменяется в ответ на действия пользователя, вызовы функций и другие события.

```javascript
// Состояние
let state = 1

function multiple() {
  // Промежуточные данные
  let tempState = state
  for (let i = state; i < state * 2; i++) {
    tempState += 1
  }
  state = tempState
}
```
Примеры состояний: State manager, useState, DOM, Cookie, База данных, localStorage. Код также является состоянием.

Дублирование – это когда в системе существуют два или более состояния, которые содержат разные данные, но при декодировании дают одну и ту же информацию.

Пример дублирования состояния:

```javascript
const user = {
  id: 1,
  age: 14
}

const adult_users = {
  1: false
}
```

В этом примере переменные `user` и `adult_users` представляют собой дублирование состояния. Хотя они содержат разные данные, обе переменные дают информацию о том, является ли пользователь совершеннолетним. Переменная `user` хранит возраст, а `adult_users` хранит булевое значение, указывающее на совершеннолетие. Оба состояния могут быть использованы для определения одного и того же факта, что приводит к дублированию информации.

:::note
Дублирование информации создает риск, что данные будут изменены в одном состоянии, а в другом останутся без изменений. Это может привести к тому, что состояния и данные будут различаться, что вызовет неконсистентность. В результате информация об одном и том же объекте в двух разных источниках может противоречить друг другу.
:::

### Кэш
Кэш – дублирование состояния для экономии вычислительных мощностей.

Пример кэша:

```javascript
const [users, setUsers] = useState()

useEffect(() => {
  fetch('http://localhost:3000/users')
    .then(r => r.json())
    .then(setUsers)
}, [])

const getUserById = (id) =>
  users.find(user => user.id === id)
```


В примере выше используется `useState` для хранения пользователей и `useEffect` для однократной загрузки данных с сервера. Данные кэшируются в `users`. Функция `getUserById` ищет пользователя в этом кэше, избегая повторных запросов к серверу.
